<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Particles</title>
    <style>
        canvas {
            position: absolute;
            left: 0;
            top: 0;
        }

        body {
            background-color: black;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix.js"
            integrity="sha512-zhHQR0/H5SEBL3Wn6yYSaTTZej12z0hVZKOv3TwCUXT1z5qeqGcXJLLrbERYRScEDDpYIJhPC1fk31gqR783iQ=="
            crossorigin="anonymous" defer>
    </script>
</head>
<body>
<canvas id="canvas"></canvas>
<script id="vert_shader" type="x-shader/x-vertex">
    attribute vec4 a_position;

    void main() {
        gl_Position = a_position;
    }
</script>
<script id="frag_shader" type="x-shader/x-fragment">
    // fragment shaders don't have a default precision so we need
    // to pick one. mediump is a good default
    precision mediump float;

    void main() {
        gl_FragColor = vec4(0, 0.5, 0, 1);
    }
</script>
<script>

    function compileShader(gl, type, source) {
        const shader = gl.createShader(type)

        gl.shaderSource(shader, source)
        gl.compileShader(shader)

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createShaderFromScript(gl, scriptId, shaderType) {
        let shaderScript = document.getElementById(scriptId);
        if (!shaderScript) {
            throw("*** Error: unknown script element" + scriptId);
        }
        switch (shaderType) {
            case gl.VERTEX_SHADER:
                if (shaderScript.type !== "x-shader/x-vertex") {
                    throw("script/shader type mismatch")
                }
                break
            case gl.FRAGMENT_SHADER:
                if (shaderScript.type !== "x-shader/x-fragment") {
                    throw("script/shader type mismatch")
                }
                break
        }
        return compileShader(gl, shaderType, shaderScript.text);
    }

    function createProgram(gl, vsSource, fsSource) {
        const vertexShader = createShaderFromScript(gl, vsSource, gl.VERTEX_SHADER);
        const fragmentShader = createShaderFromScript(gl, fsSource, gl.FRAGMENT_SHADER);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return null;
        }

        return shaderProgram;
    }

    function createBuffers(gl) {
        const positions = [
            -1, -1,
            1, -1,
            1, 1,
            -1, 1
        ]
        const positionBuffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)
        return {
            positionBuffer,
        }
    }

    function render(gl, programInfo, buffers) {
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
        gl.clearColor(0, 0, 0, 1)
        gl.clear(gl.COLOR_BUFFER_BIT)

        gl.useProgram(programInfo.program)
        gl.enableVertexAttribArray(programInfo.attribLocations.position)
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.positionBuffer)
        gl.vertexAttribPointer(programInfo.attribLocations.position, 2, gl.FLOAT, false, 0, 0)
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
    }

    function main() {
        const canvas = document.getElementById("canvas")
        canvas.height = window.innerHeight
        canvas.width = window.innerWidth
        const gl = canvas.getContext("webgl")
        if (!gl) {
            return
        }
        const shaderProgram = createProgram(gl, "vert_shader", "frag_shader")

        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                position: gl.getAttribLocation(shaderProgram, "a_position")
            }
        }
        const buffers = createBuffers(gl)

        render(gl, programInfo, buffers)
    }

    window.onload = main
</script>
</body>
</html>